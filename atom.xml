<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chad</title>
  
  <subtitle>一個對世界好奇的iOS Developer，時常玩玩 Android 小綠機器人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chadchang.github.io/"/>
  <updated>2018-06-27T16:31:49.690Z</updated>
  <id>http://chadchang.github.io/</id>
  
  <author>
    <name>Chad Chang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>genstrings script 同時支援 objc&amp;swift</title>
    <link href="http://chadchang.github.io/2018/06/26/genstring-for-objc-swift/"/>
    <id>http://chadchang.github.io/2018/06/26/genstring-for-objc-swift/</id>
    <published>2018-06-26T15:04:56.000Z</published>
    <updated>2018-06-27T16:31:49.690Z</updated>
    
    <content type="html"><![CDATA[<p>因 project 要開始慢慢導入 swift，不小心可能就沒注意到原本 genstrings script 不會處理 swift file,<br>而要改成能同時支援<code>.m</code>與<code>.swift</code>檔的 script</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find $&#123;SRCROOT&#125;/MyApp/ \( -name &quot;*.swift&quot; -o -name &quot;*.m&quot; \) -print0 | xargs -0 genstrings -o $&#123;SRCROOT&#125;/MyApp/zh-Hant.lproj</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因 project 要開始慢慢導入 swift，不小心可能就沒注意到原本 genstrings script 不會處理 swift file,&lt;br&gt;而要改成能同時支援&lt;code&gt;.m&lt;/code&gt;與&lt;code&gt;.swift&lt;/code&gt;檔的 script&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chadchang.github.io/tags/Swift/"/>
    
      <category term="Objc" scheme="http://chadchang.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>上了 Apple Store Today !!</title>
    <link href="http://chadchang.github.io/2018/05/25/apple-today/"/>
    <id>http://chadchang.github.io/2018/05/25/apple-today/</id>
    <published>2018-05-25T10:49:44.000Z</published>
    <updated>2018-05-31T01:12:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 P 社滿五年了，在 2016/11/04 的 “同一天 App Store、Google Play 雙 Feature” 之後，17 年又經過 apple pay 台灣首發的 app 跟官網 promote 的 app 後，18 年又達到在 App Store 首頁被選為 Today 的成就，值得再紀念一下。</p><p><img src="/images/today_1.PNG" alt="Today"> <img src="/images/today_2.PNG" alt="Today"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 P 社滿五年了，在 2016/11/04 的 “同一天 App Store、Google Play 雙 Feature” 之後，17 年又經過 apple pay 台灣首發的 app 跟官網 promote 的 app 後，18 年又達到在 App Store 首頁被選
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="App Store" scheme="http://chadchang.github.io/tags/App-Store/"/>
    
      <category term="Work" scheme="http://chadchang.github.io/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>用 Atom 寫 markdown</title>
    <link href="http://chadchang.github.io/2016/12/05/switch-to-atom/"/>
    <id>http://chadchang.github.io/2016/12/05/switch-to-atom/</id>
    <published>2016-12-05T10:42:47.000Z</published>
    <updated>2018-05-30T03:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Atom 剛發表時有安裝玩了一下，但當時不知道為什麼覺得不好用，直到又再翻到 <a href="http://www.slideshare.net/alemur1/atom-text-editor-resistance-is-futile" target="_blank" rel="noopener">Atom Text Editor: Resistance is Futile</a> 這份投影片，重新安裝 Atom 後光看畫面就很舒服，這篇也是在 Atom 底下寫出來的。建立好 markdown 的環境後，就可以與 sublime text 與 macdown 說再見了。<br><a id="more"></a></p><ol><li>環境修改： Settings -&gt; Core -&gt; Open Empty Editor on Start -&gt; 設定為關閉，否則每次開啟都會出現挺煩人的。</li><li>安裝 <code>markdown-writer</code> package<br>因此 package 將預設的 keymap 關閉，因此需在 Atom 上方的 File -&gt; Keymap 加上:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">".platform-darwin atom-text-editor[data-grammar~='gfm']"</span>:</span><br><span class="line">  <span class="string">"shift-cmd-K"</span>: <span class="string">"markdown-writer:insert-link"</span></span><br><span class="line">  <span class="string">"shift-cmd-I"</span>: <span class="string">"markdown-writer:insert-image"</span></span><br><span class="line">  <span class="string">"cmd-i"</span>:       <span class="string">"markdown-writer:toggle-italic-text"</span></span><br><span class="line">  <span class="string">"cmd-b"</span>:       <span class="string">"markdown-writer:toggle-bold-text"</span></span><br><span class="line">  <span class="string">"shift-cmd-'"</span>: <span class="string">"markdown-writer:toggle-code-text"</span></span><br><span class="line">  <span class="string">"cmd-k"</span>:       <span class="string">"markdown-writer:toggle-keystroke-text"</span></span><br><span class="line">  <span class="string">"cmd-h"</span>:       <span class="string">"markdown-writer:toggle-strikethrough-text"</span></span><br><span class="line">  <span class="string">"ctrl-alt-1"</span>:  <span class="string">"markdown-writer:toggle-h1"</span></span><br><span class="line">  <span class="string">"ctrl-alt-2"</span>:  <span class="string">"markdown-writer:toggle-h2"</span></span><br><span class="line">  <span class="string">"ctrl-alt-3"</span>:  <span class="string">"markdown-writer:toggle-h3"</span></span><br><span class="line">  <span class="string">"ctrl-alt-4"</span>:  <span class="string">"markdown-writer:toggle-h4"</span></span><br><span class="line">  <span class="string">"ctrl-alt-5"</span>:  <span class="string">"markdown-writer:toggle-h5"</span></span><br><span class="line">  <span class="string">"shift-cmd-O"</span>: <span class="string">"markdown-writer:toggle-ol"</span></span><br><span class="line">  <span class="string">"shift-cmd-U"</span>: <span class="string">"markdown-writer:toggle-ul"</span></span><br><span class="line">  <span class="string">"shift-cmd-&gt;"</span>: <span class="string">"markdown-writer:toggle-blockquote"</span></span><br><span class="line">  <span class="string">"cmd-'"</span>: <span class="string">"markdown-writer:toggle-codeblock-text"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-p"</span>: <span class="string">"markdown-writer:jump-to-previous-heading"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-n"</span>: <span class="string">"markdown-writer:jump-to-next-heading"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-d"</span>: <span class="string">"markdown-writer:jump-to-reference-definition"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-t"</span>: <span class="string">"markdown-writer:jump-to-next-table-cell"</span></span><br></pre></td></tr></table></figure><p>注意： 這邊我將 code block 快捷鍵改為 <em>cmd-‘</em> 因為比 inline code 常用</p><ol start="3"><li>因較常使用 objc 的 code，將 code block 預設改為 “<code>objc</code>“ 樣式，設定檔修改請參考 <a href="https://github.com/zhuochun/md-writer/wiki/Settings" target="_blank" rel="noopener">Settings · zhuochun/md-writer Wiki</a> 與 <a href="https://github.com/zhuochun/md-writer/wiki/Settings-for-individual-projects" target="_blank" rel="noopener">Settings for Individual Projects · zhuochun/md-writer Wiki</a></li></ol><p>（以上兩點大大解決每次在 Mackdown 貼 code 的不便）</p><ol start="4"><li><p>因偶爾會使用 swift code，為了讓 Atom 認識 swift style，需安裝 <code>language-swift</code> package</p></li><li><p><code>ctrl - shift - m</code> 可以預覽。</p></li></ol><p>另外，用 <code>hexo</code> 的話，有 <code>Atom-Hexo</code> package 可以使用， markdown-writer 內也可以針對 site 詳細設定，但因為我都是用 terminal，所以這部份就忽略了，有興趣的話可以自己調整。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Atom 剛發表時有安裝玩了一下，但當時不知道為什麼覺得不好用，直到又再翻到 &lt;a href=&quot;http://www.slideshare.net/alemur1/atom-text-editor-resistance-is-futile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Atom Text Editor: Resistance is Futile&lt;/a&gt; 這份投影片，重新安裝 Atom 後光看畫面就很舒服，這篇也是在 Atom 底下寫出來的。建立好 markdown 的環境後，就可以與 sublime text 與 macdown 說再見了。&lt;br&gt;
    
    </summary>
    
    
      <category term="Atom" scheme="http://chadchang.github.io/tags/Atom/"/>
    
      <category term="editor" scheme="http://chadchang.github.io/tags/editor/"/>
    
      <category term="markdown" scheme="http://chadchang.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>規劃自己人生的方式</title>
    <link href="http://chadchang.github.io/2016/12/02/life-plan/"/>
    <id>http://chadchang.github.io/2016/12/02/life-plan/</id>
    <published>2016-12-02T06:02:32.000Z</published>
    <updated>2017-01-02T13:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在思考人生，看到相關的文章等就會特別注意，這邊筆記一下收集到的一些資料。<br><a id="more"></a></p><h4 id="How-to-Crush-Your-Goals-in-2017-According-to-Harvard-Research-–-The-Mission-–-Medium"><a href="#How-to-Crush-Your-Goals-in-2017-According-to-Harvard-Research-–-The-Mission-–-Medium" class="headerlink" title="How to Crush Your Goals in 2017, According to Harvard Research – The Mission – Medium"></a><a href="https://medium.com/the-mission/how-to-crush-your-goals-in-2017-according-to-harvard-psychologists-1e82beb80677#.qll6y9uu4" target="_blank" rel="noopener">How to Crush Your Goals in 2017, According to Harvard Research – The Mission – Medium</a></h4><blockquote><p>研究指出只有 8% 的人可以完成年度計畫。</p></blockquote><p>本篇可以與<a href="http://www.rich01.com/2017/01/201710.html?m=1" target="_blank" rel="noopener">2017如何設定目標？哈佛大學研究：一個小技巧，比別人成功10倍！ - Mr. Market 市場先生 - 投資理財入門</a> 搭配一起看，概念是差不多的</p><ul><li>取代壞習慣</li><li>建立小目標</li><li>留心獎項</li><li>目標明確<ul><li>可量化：退休 -&gt; 存下500萬退休金</li><li>面對現實、有可能達成： 賺一億＆上火星等不切實際</li><li>有時效性</li><li>明確的計畫： 減肥五公斤，是目標卻無法執行，每天跑 5 km 就明確多了</li></ul></li></ul><p>兩個小技巧：</p><ol><li>寫下會遇到的障礙</li><li>寫下願意付出的代價：我今年要看 100本書，靠每天通勤，及中午休息的時間進行，可能會很累但值得</li></ol><h4 id="How-To-Invest-In-Yourself"><a href="#How-To-Invest-In-Yourself" class="headerlink" title="How To Invest In Yourself"></a><a href="https://medium.com/hi-my-name-is-jon/how-to-invest-in-yourself-a98dfd33e81a#.e4jxth2w7" target="_blank" rel="noopener">How To Invest In Yourself</a></h4><ul><li>記事本</li><li>Spreadsheet (Airtable)</li><li>Browser</li><li>Calendar</li></ul><p>Setp 1: 100 件事情，兩周持續修改調整</p><p>Step 2: 分成三類：</p><ol><li>需要技能才能做<br>建立技能樹表，分成四欄：</li></ol><ul><li>skill 名稱</li><li>Research</li><li>Action</li><li>Progress</li></ul><ol start="2"><li><p>可以立刻做的<br>立刻做吧</p></li><li><p>需要時間做<br>安排時間，變成一個固定的行程</p></li></ol><p>作者在每天早餐時讀他的列表，這也是一種動力。</p><h4 id="三個問題弄清楚自己想做什麼"><a href="#三個問題弄清楚自己想做什麼" class="headerlink" title="三個問題弄清楚自己想做什麼"></a><a href="https://m.igetget.com/share/audio/aid/Yqua0jl95GivuOFdvlC0?from=singlemessage&amp;isappinstalled=1" target="_blank" rel="noopener">三個問題弄清楚自己想做什麼</a></h4><p>這三個問題分別是</p><ol><li>如果世界上所有工作的收入都是一樣的，那你會做什麼？</li><li>你希望自己的孩子以後做什麼？</li><li>如果還有十年的壽命，你會做什麼？</li></ol><p>的確以前的舉例都會用你死前到底要做什麼來思考，這篇文章給了不同的方向: <code>10 年</code>。這樣想出來的答案才不會單單只是陪伴家人等在短時間必須的事。而十年中，每件事都是三個月左右以上的事情，然後規劃去做。</p><h4 id="1年計畫，看到10年後的自己"><a href="#1年計畫，看到10年後的自己" class="headerlink" title="1年計畫，看到10年後的自己"></a><a href="http://www.30.com.tw/article_content_24691.html" target="_blank" rel="noopener">1年計畫，看到10年後的自己</a></h4><p>決定出今年要做的 10 件事情</p><p>STEP1：不要受限於10件這個數字，而是很自由地想，接下來的一年中，如果什麼都可以的話，你想要完成的事情一共有哪些，請列出一張清單，內容愈詳細愈好，愈明確愈好，即使20項、30項也沒有關係。</p><p>STEP2：這些事情當中，是否有些在一年之後，有做到也可以，沒做到也沒關係的事情？如果有的話，請把那些項目畫掉。</p><p>STEP3：在剩下的清單中，請刪去那些雖然想做，但是自己心知肚明，一定做不到，或是不會去做的事。</p><p>STEP4：剩餘的清單裡，有沒有哪些事就算沒有人規定，我也非做不可，就算沒人注意到也沒關係，因為這些事情對我來說很重要？挑出這些事情來，放到最前面。</p><p>最後剩下的，才是真正今年值得完成的10件事。</p><p>跟未來的我對話</p><ul><li>10年後，我會長什麼樣子？</li><li>10年後，我住在什麼樣的房子？這間房子在哪裡？</li><li>10年後，我想看自己身上穿什麼衣服？</li><li>10年後，我身邊有什麼人？他們跟我的關係是什麼？</li><li>10年後，我會每天工作嗎？做什麼？工作型態如何？</li></ul><h4 id="你想要過怎麼樣的人生？畫一張「夢想金字塔」，決定努力的方向！｜經理人"><a href="#你想要過怎麼樣的人生？畫一張「夢想金字塔」，決定努力的方向！｜經理人" class="headerlink" title="你想要過怎麼樣的人生？畫一張「夢想金字塔」，決定努力的方向！｜經理人"></a><a href="https://www.managertoday.com.tw/articles/view/53559" target="_blank" rel="noopener">你想要過怎麼樣的人生？畫一張「夢想金字塔」，決定努力的方向！｜經理人</a></h4><p>一文則有兩張不錯的圖幫我們去思考不同方向</p><p><img src="/images/pyramid.jpeg" alt="夢想金字塔"></p><p><img src="/images/my_grid.jpeg" alt="九宮格"></p><h4 id="【Hi！35】7件事，為你的職場35歲做準備"><a href="#【Hi！35】7件事，為你的職場35歲做準備" class="headerlink" title="【Hi！35】7件事，為你的職場35歲做準備"></a><a href="https://plus.104.com.tw/activity/d9f73096-a4bf-4ee1-8d0f-5a69cea9462b" target="_blank" rel="noopener">【Hi！35】7件事，為你的職場35歲做準備</a></h4><ol><li>確認自己未來的職涯方向：並朝目標建構職涯發展的計畫，比如40歲前應該要擔任公司中高階主管（如資深經理、處長、協理職務），或是念完碩士在職專班學程。</li><li>努力適應職場文化：由於年齡已經老大不小了，應該要更認真投入職場，累積個人在職場上的成功經驗，例如為公司創造具體貢獻與實績、為公司與自己取得政府及其他機構的肯定（如取得傑出經理人或國家級的獎項），此時不宜再輕易轉換工作。</li></ol><ol start="3"><li><p>努力學習與持續成長：這時期的充電學習與成長格外重要，不管是強化自己的專業領域，或是英文、日文、韓文、越南文等國際語文，都是讓自己成為國際人才所必需的投資。</p></li><li><p>調整習慣與興趣：隨著年紀逐漸增長，過去如果沒有養成良好運動、閱讀、飲食、睡眠、紓壓的習慣或興趣，35歲以後就必須開始培養適當的興趣，不宜再浪擲人生了。</p></li><li><p>積極表現、獲得晉升：有些人在30歲到40歲階段能夠展現優越的專業知識，發揮成熟的領導魅力，因此屢受拔擢，從課長或主任職級，一路晉升副理、經理到處長職務，這階段需要積極展現工作的投入與熱忱。</p></li><li><p>增強人際介面與互動：隨著工作資歷的成長，必須廣結善緣，在各類場合認識與結交職場的貴人，如有餘力時，參加非營利組織或擔任志工，為協助他人與社會盡一份心力。此時家族長輩的年齡及健康狀況不如過往，撥出空檔時間多陪伴長輩，也是強化家族人際關係的作法。</p></li><li><p>透過職涯社群建立個人形象：例如在104職涯社群建立個人檔案，分享自己的職涯發展、專業技能證照、管理心得與成功經驗；在臉書分享自己的生活動態與交友狀況，都能夠讓企業家或是人資主管得知您的價值，讓企業主動邀請您加入經營團隊。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在思考人生，看到相關的文章等就會特別注意，這邊筆記一下收集到的一些資料。&lt;br&gt;
    
    </summary>
    
    
      <category term="plan" scheme="http://chadchang.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>Common Background Practice</title>
    <link href="http://chadchang.github.io/2016/11/21/background-practices/"/>
    <id>http://chadchang.github.io/2016/11/21/background-practices/</id>
    <published>2016-11-21T15:04:56.000Z</published>
    <updated>2016-11-21T15:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/issues/2-concurrency/common-background-practices/" target="_blank" rel="noopener">Common Background Practices - objc.io issue #2</a> 的整理筆記</p><a id="more"></a><h3 id="import-一大組資料-with-progress-bar"><a href="#import-一大組資料-with-progress-bar" class="headerlink" title="import 一大組資料 with progress bar"></a>import 一大組資料 with progress bar</h3><p>Start Import<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ImportOperation* operation = [[ImportOperation alloc] initWithStore:<span class="keyword">self</span>.store fileName:fileName];</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：更新 progress 必須在 main thread</span></span><br><span class="line">operation.progressCallback = ^(<span class="keyword">float</span> progress) &#123;</span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.progressIndicator.progress = progress;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br></pre></td></tr></table></figure></p><p>ImportOperation<br><figure class="highlight objc"><figcaption><span>ImportOperation.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithStore:(Store*)store fileName:(<span class="built_in">NSString</span>*)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.store = store;</span><br><span class="line">        <span class="keyword">self</span>.fileName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> can we use new in the name? I think it's bad style, any ideas for a better name?</span></span><br><span class="line">    <span class="keyword">self</span>.context = [<span class="keyword">self</span>.store newPrivateContext];</span><br><span class="line">    <span class="keyword">self</span>.context.undoManager = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.context performBlockAndWait:^</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> import];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)import</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* fileContents = [<span class="built_in">NSString</span> stringWithContentsOfFile:<span class="keyword">self</span>.fileName encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    <span class="built_in">NSArray</span>* lines = [fileContents componentsSeparatedByCharactersInSet:[<span class="built_in">NSCharacterSet</span> newlineCharacterSet]];</span><br><span class="line">    <span class="built_in">NSInteger</span> count = lines.count;</span><br><span class="line">    <span class="comment">// 每 100 行才更新一次 progress 避免阻塞</span></span><br><span class="line">    <span class="built_in">NSInteger</span> progressGranularity = count/<span class="number">100</span>;</span><br><span class="line">    __block <span class="built_in">NSInteger</span> idx = <span class="number">-1</span>;</span><br><span class="line">    [fileContents enumerateLinesUsingBlock:^(<span class="built_in">NSString</span>* line, <span class="built_in">BOOL</span>* shouldStop)</span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// header line</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 支持取消功能</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            *shouldStop = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSArray</span>* components = [line csvComponents];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (components.count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"couldn't parse: %@"</span>, components);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [Stop importCSVComponents:components intoContext:<span class="keyword">self</span>.context];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx % progressGranularity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.progressCallback(idx / (<span class="keyword">float</span>) count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx % ImportBatchSize == <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.context save:<span class="literal">NULL</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.progressCallback(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.context save:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Asynchronous-Networking"><a href="#Asynchronous-Networking" class="headerlink" title="Asynchronous Networking"></a>Asynchronous Networking</h3><p>不可以使用以下代碼，因為不可以取消，會阻塞 thread，在並行時也需要多一個 thread</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">   <span class="built_in">NSData</span>* contents = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]</span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="comment">// 處理 data</span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 <code>NSURLConnection</code> or <code>NSURLSessionConnection</code> 來解決</p><h3 id="File-I-O-in-the-Background"><a href="#File-I-O-in-the-Background" class="headerlink" title="File I/O in the Background"></a>File I/O in the Background</h3><p>當文件太大時，則需要一行一行的讀取而不是一次將整個文件讀入</p><figure class="highlight objc"><figcaption><span>Reader</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Reader</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block</span><br><span class="line">            completion:(<span class="keyword">void</span> (^)())completion;</span><br><span class="line">- (<span class="keyword">id</span>)initWithFileAtPath:(<span class="built_in">NSString</span>*)path;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implement</span></span><br><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block</span><br><span class="line">            completion:(<span class="keyword">void</span> (^)())completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.queue == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.callback = block;</span><br><span class="line">    <span class="keyword">self</span>.completion = completion;</span><br><span class="line">    <span class="keyword">self</span>.inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.fileURL];</span><br><span class="line">    <span class="keyword">self</span>.inputStream.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop]</span><br><span class="line">                                forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inputStream 的 delegate</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span>*)stream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventCode) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventHasBytesAvailable</span>: &#123;</span><br><span class="line">            <span class="built_in">NSMutableData</span> *buffer = [<span class="built_in">NSMutableData</span> dataWithLength:<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">NSUInteger</span> length = [<span class="keyword">self</span>.inputStream read:[buffer mutableBytes]</span><br><span class="line">                                             maxLength:[buffer length]];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; length) &#123;</span><br><span class="line">                [buffer setLength:length];</span><br><span class="line">                __<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">                [<span class="keyword">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class="line">                    [weakSelf processDataChunk:buffer];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processDataChunk:(<span class="built_in">NSMutableData</span> *)buffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.remainder != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.remainder appendData:buffer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.remainder = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.remainder obj_enumerateComponentsSeparatedBy:<span class="keyword">self</span>.delimiter</span><br><span class="line">                                            usingBlock:^(<span class="built_in">NSData</span>* component, <span class="built_in">BOOL</span> last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!last) &#123;</span><br><span class="line">            [<span class="keyword">self</span> emitLineWithData:component];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; [component length]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = [component mutableCopy];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/issues/2-concurrency/common-background-practices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Common Background Practices - objc.io issue #2&lt;/a&gt; 的整理筆記&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="objc.io" scheme="http://chadchang.github.io/tags/objc-io/"/>
    
  </entry>
  
  <entry>
    <title>Concurrent Programming 的 API</title>
    <link href="http://chadchang.github.io/2016/11/19/objcio-2-api/"/>
    <id>http://chadchang.github.io/2016/11/19/objcio-2-api/</id>
    <published>2016-11-19T15:43:36.000Z</published>
    <updated>2016-11-20T17:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">Concurrent Programming: APIs and Challenges - objc.io issue #2</a> 的整理筆記</p><a id="more"></a><p>難 -&gt; 易 : pthread、NSThread、GCD、NSOperationQueue</p><h3 id="使用-GCD"><a href="#使用-GCD" class="headerlink" title="使用 GCD"></a>使用 GCD</h3><p>預設有五個 queue</p><ol><li>main queue</li><li>3 個不同 priority queue</li><li>I/O queue</li></ol><p>大多數情況使用 default 的 priority queue 就好，避免 <code>priority inversion</code></p><h3 id="使用-Operation-Queues"><a href="#使用-Operation-Queues" class="headerlink" title="使用 Operation Queues"></a>使用 Operation Queues</h3><p>可透過 override main or start 定義自己的 operations。</p><p>重寫 main 的方式當 return 時，這 operation 就結束了<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">    - (<span class="keyword">void</span>)main</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 進行處理 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>更多處理或者要可以 async，這情況下需要手動管理狀態，使用預設的 setter 才會發送 KVO，否則需要自己發送。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">    - (<span class="keyword">void</span>)start</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 開始處理，在結束時應該調用 finished ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    - (<span class="keyword">void</span>)finished</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.isExecuting = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.isFinished = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>為了使用 cancel，需一直檢查 isCancelled 屬性。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (notDone &amp;&amp; !<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="comment">// 進行處理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>將 operation 放到 queue 中</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">YourOperation *operation = [[YourOperation alloc] init];</span><br><span class="line">[queue  addOperation:operation];</span><br></pre></td></tr></table></figure><p>也可以直接將 block 放到 queue 中，但定義自己的 NSOperation 會比較好 debug。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 代碼...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>NSOperation 還可以透過 <code>maxConcurrentOperationCount</code> 控制同時執行的數量，還有根據 queue 中的 operation 的 priority 排序，還可以在 operation 之間設 dependency。</p><p>而性能雖然比 GCD 要低一點，但大多數可以忽略不計。</p><h3 id="使用-NSThread"><a href="#使用-NSThread" class="headerlink" title="使用 NSThread"></a>使用 NSThread</h3><p>使用這的問題是在我們的 code 中也做了建立 thread 的事情，可能導致 threads 爆炸。</p><figure class="highlight objc"><figcaption><span>FindMinMaxThread.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FindMinMaxThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> min;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> max;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FindMinMaxThread.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FindMinMaxThread</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _numbers = numbers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> min;</span><br><span class="line">    <span class="built_in">NSUInteger</span> max;</span><br><span class="line">    <span class="comment">// 進行相關數據的處理</span></span><br><span class="line">    <span class="keyword">self</span>.min = min;</span><br><span class="line">    <span class="keyword">self</span>.max = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>呼叫的方式<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableSet</span> *threads = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line"><span class="built_in">NSUInteger</span> numberCount = <span class="keyword">self</span>.numbers.count;</span><br><span class="line"><span class="built_in">NSUInteger</span> threadCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> offset = (count / threadCount) * i;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(offset, count);</span><br><span class="line">    <span class="built_in">NSArray</span> *subset = [<span class="keyword">self</span>.numbers subarrayWithRange:range];</span><br><span class="line">    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class="line">    [threads addObject:thread];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-pthread"><a href="#使用-pthread" class="headerlink" title="使用 pthread"></a>使用 pthread</h3><p>複雜不易使用</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> threadInfo &#123;</span><br><span class="line">    uint32_t * inputValues;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> threadResult &#123;</span><br><span class="line">    uint32_t min;</span><br><span class="line">    uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * findMinAndMax(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> threadInfo <span class="keyword">const</span> * <span class="keyword">const</span> info = (<span class="keyword">struct</span> threadInfo *) arg;</span><br><span class="line">    uint32_t min = <span class="built_in">UINT32_MAX</span>;</span><br><span class="line">    uint32_t max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; info-&gt;count; ++i) &#123;</span><br><span class="line">        uint32_t v = info-&gt;inputValues[i];</span><br><span class="line">        min = MIN(min, v);</span><br><span class="line">        max = MAX(max, v);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arg);</span><br><span class="line">    <span class="keyword">struct</span> threadResult * <span class="keyword">const</span> result = (<span class="keyword">struct</span> threadResult *) malloc(<span class="keyword">sizeof</span>(*result));</span><br><span class="line">    result-&gt;min = min;</span><br><span class="line">    result-&gt;max = max;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    size_t <span class="keyword">const</span> count = <span class="number">1000000</span>;</span><br><span class="line">    uint32_t inputValues[count];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用隨機數字填充 inputValues</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        inputValues[i] = arc4random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 開始4個尋找最小值和最大值的線程</span></span><br><span class="line">    size_t <span class="keyword">const</span> threadCount = <span class="number">4</span>;</span><br><span class="line">    pthread_t tid[threadCount];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> threadInfo * <span class="keyword">const</span> info = (<span class="keyword">struct</span> threadInfo *) malloc(<span class="keyword">sizeof</span>(*info));</span><br><span class="line">        size_t offset = (count / threadCount) * i;</span><br><span class="line">        info-&gt;inputValues = inputValues + offset;</span><br><span class="line">        info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(tid + i, <span class="literal">NULL</span>, &amp;findMinAndMax, info);</span><br><span class="line">        <span class="built_in">NSCAssert</span>(err == <span class="number">0</span>, <span class="string">@"pthread_create() failed: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待線程退出</span></span><br><span class="line">    <span class="keyword">struct</span> threadResult * results[threadCount];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> err = pthread_join(tid[i], (<span class="keyword">void</span> **) &amp;(results[i]));</span><br><span class="line">        <span class="built_in">NSCAssert</span>(err == <span class="number">0</span>, <span class="string">@"pthread_join() failed: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尋找 min 和 max</span></span><br><span class="line">    uint32_t min = <span class="built_in">UINT32_MAX</span>;</span><br><span class="line">    uint32_t max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        min = MIN(min, results[i]-&gt;min);</span><br><span class="line">        max = MAX(max, results[i]-&gt;max);</span><br><span class="line">        free(results[i]);</span><br><span class="line">        results[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"min = %u"</span>, min);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"max = %u"</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Concurrent Programming: APIs and Challenges - objc.io issue #2&lt;/a&gt; 的整理筆記&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="objc.io" scheme="http://chadchang.github.io/tags/objc-io/"/>
    
  </entry>
  
  <entry>
    <title>做一個 Side Project</title>
    <link href="http://chadchang.github.io/2016/11/08/side-project/"/>
    <id>http://chadchang.github.io/2016/11/08/side-project/</id>
    <published>2016-11-08T13:24:39.000Z</published>
    <updated>2018-06-01T06:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 App 寫了 六七年後，反而想再回去寫一點 Web 等不同於 App 的東西，畢竟過了這麼多年，現在整個 Web 世界又大大不同了。看到灣區日報的作者一直在持續推進他的東西，也學寫了 App 而且更新頻繁，一直在想自己有沒有可以效法他好好做一個自己用會感到興奮的東西。在思考之餘，剛好又在灣區日報看到了這篇 <a href="https://ponyfoo.com/articles/making-time-for-side-projects" target="_blank" rel="noopener">Making Time for Side Projects: A Daily Habit</a>，更確定是該來做些什麼了 :smile:</p><ol><li>It’s easier to get started</li><li>The pressure is off</li><li>You stop relying on motivation &amp; inspiration</li></ol><p>灣區日報作者的經驗我覺得很值得可以參考:</p><blockquote><p>我的經驗是，做 side project 的話，家裡的電腦永遠不關機，永遠開著 IDE、開發用的虛擬機、瀏覽器的 DevTools、iTerm2 等，每天有時間就做個 1、2 小時，沒時間弄個 10 分鐘、15 分鐘改個字體大小、顏色啥的也行，保持開發環境不變，第二天一有空閒就能接下去寫、很快進入狀態。</p></blockquote><p>每天都投入一點，即便只是五分鐘十分鐘，都是讓 side project 更前進。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 App 寫了 六七年後，反而想再回去寫一點 Web 等不同於 App 的東西，畢竟過了這麼多年，現在整個 Web 世界又大大不同了。看到灣區日報的作者一直在持續推進他的東西，也學寫了 App 而且更新頻繁，一直在想自己有沒有可以效法他好好做一個自己用會感到興奮的東西。在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同一天 App Store、Google Play 雙 Feature</title>
    <link href="http://chadchang.github.io/2016/10/21/feature/"/>
    <id>http://chadchang.github.io/2016/10/21/feature/</id>
    <published>2016-10-20T16:49:44.000Z</published>
    <updated>2016-11-03T17:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>App 從無到有的開發三年多，每天與同事們灌溉著 iOS/Android 這兩版本的 App，雖然已經上榜很多次，但這次是比較重大的，且兩版本同一天被 Feature 對我而言也是挺難得的。發文紀念一下。也謝謝強大的同事們的力量讓這 App 可以飛上天空。</p><p><img src="/images/app_store_feature.jpg" alt="App Store Feature"> <img src="/images/google_play_feature.png" alt="Google Play Feature"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;App 從無到有的開發三年多，每天與同事們灌溉著 iOS/Android 這兩版本的 App，雖然已經上榜很多次，但這次是比較重大的，且兩版本同一天被 Feature 對我而言也是挺難得的。發文紀念一下。也謝謝強大的同事們的力量讓這 App 可以飛上天空。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="App Store" scheme="http://chadchang.github.io/tags/App-Store/"/>
    
      <category term="Android" scheme="http://chadchang.github.io/tags/Android/"/>
    
      <category term="Google Play" scheme="http://chadchang.github.io/tags/Google-Play/"/>
    
      <category term="Work" scheme="http://chadchang.github.io/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>GCD 筆記</title>
    <link href="http://chadchang.github.io/2014/05/10/gcd/"/>
    <id>http://chadchang.github.io/2014/05/10/gcd/</id>
    <published>2014-05-10T04:08:00.000Z</published>
    <updated>2016-11-19T01:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>參考 <a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="noopener">Grand Central Dispatch In-Depth</a> 的筆記。</p><ul><li>Critical Section</li><li>Race Condition</li><li>Deadlock</li><li>Context Switch</li></ul><a id="more"></a><h3 id="背景讀取-dispatch-async"><a href="#背景讀取-dispatch-async" class="headerlink" title="背景讀取 dispatch_async"></a>背景讀取 dispatch_async</h3><figure class="highlight objc"><figcaption><span>PhotoDetailViewController.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;   </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSAssert</span>(_image, <span class="string">@"Image not set; required to use view controller"</span>);</span><br><span class="line">    <span class="keyword">self</span>.photoImageView.image = _image;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Resize if neccessary to ensure it's not pixelated</span></span><br><span class="line">    <span class="keyword">if</span> (_image.size.height &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.height &amp;&amp;</span><br><span class="line">        _image.size.width &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.width) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.photoImageView setContentMode:<span class="built_in">UIViewContentModeCenter</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">UIImage</span> *overlayImage = [<span class="keyword">self</span> faceOverlayImageFromImage:_image];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 2</span></span><br><span class="line">            [<span class="keyword">self</span> fadeInNewImage:overlayImage]; <span class="comment">// 3</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="幾秒後提示-dispatch-after"><a href="#幾秒後提示-dispatch-after" class="headerlink" title="幾秒後提示 dispatch_after"></a>幾秒後提示 dispatch_after</h3><p><img src="/images/gcdpromotes.png" alt="GCD promote"></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showOrHideNavPrompt PhotoCollectionViewController.m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [[PhotoManager sharedManager] photos].count;</span><br><span class="line">    <span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>)); <span class="comment">// 1 </span></span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123; <span class="comment">// 2 </span></span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="string">@"Add photos with faces to Googlyify them!"</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_after 最好使用在 main queue</strong></p><ul><li>Custom Serial Queue: Use caution when using dispatch_after on a custom serial queue. You’re better off sticking to the main queue.</li><li>Main Queue (Serial): This is a good choice for dispatch_after; Xcode has a nice autocomplete template for this.</li><li>Concurrent Queue: Use caution when using dispatch_after on custom concurrent queues; it’s rare that you’ll do this. Stick to the main queue for these operations.</li></ul><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讀寫問題-dispatch-barrier"><a href="#讀寫問題-dispatch-barrier" class="headerlink" title="讀寫問題 dispatch_barrier"></a>讀寫問題 dispatch_barrier</h3><p>問題</p><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (photo) &#123;</span><br><span class="line">        [_photosArray addObject:photo];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> postContentAddedNotification];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)photos</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:_photosArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_barrier 最好使用在 Custom Concurrent Queue</strong></p><ul><li>Custom Serial Queue: A bad choice here; barriers won’t do anything helpful since a serial queue executes one operation at a time anyway.</li><li>Global Concurrent Queue: Use caution here; this probably isn’t the best idea since other systems might be using the queues and you don’t want to monopolize them for your own purposes.</li><li>Custom Concurrent Queue: This is a great choice for atomic or critical areas of code. Anything you’re setting or instantiating that needs to be thread safe is a great candidate for a barrier.</li></ul><p>修正</p><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PhotoManager</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *photosArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentPhotoQueue; <span class="comment">///&lt; Add this</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ADD THIS:</span></span><br><span class="line">sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(<span class="string">"com.selander.GooglyPuff.photoQueue"</span>,DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">                                                    </span><br><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (photo) &#123; <span class="comment">// 1</span></span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2 </span></span><br><span class="line">            [_photosArray addObject:photo]; <span class="comment">// 3</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 4</span></span><br><span class="line">                [<span class="keyword">self</span> postContentAddedNotification]; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)photos</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *array; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2</span></span><br><span class="line">        array = [<span class="built_in">NSArray</span> arrayWithArray:_photosArray]; <span class="comment">// 3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h3><p>在讀取時，reader function 沒return時是無效的，所以採用<code>dispatch_sync</code></p><p>讓 read 使用 sync 且與 write 在同一個 concurrent queeue 是確保 read ＆ wirte 有順序，且避免多 thread 讀寫。</p><p><strong>dispatch_sync 最好使用在 Custom Concurrent Queue</strong></p><ul><li>Custom Serial Queue: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock.</li><li>Main Queue (Serial): Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition.</li><li>Concurrent Queue: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing.</li></ul><h3 id="全部圖片下載完後提示-dispatch-group"><a href="#全部圖片下載完後提示-dispatch-group" class="headerlink" title="全部圖片下載完後提示 dispatch_group"></a>全部圖片下載完後提示 dispatch_group</h3><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">        __block <span class="built_in">NSError</span> *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *url;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            dispatch_group_enter(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                      <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); <span class="comment">// 4</span></span><br><span class="line">                                  &#125;];</span><br><span class="line"> </span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123; <span class="comment">// 7</span></span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_group 皆可使用在各種 Queue</strong></p><ul><li>Custom Serial Queue: This is a good candidate for notifications when a group of tasks completes.</li><li>Main Queue (Serial): This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls.</li><li>Concurrent Queue: This as well is a good candidate for dispatch groups and completion notifications.</li></ul><p><strong>比較簡潔方式</strong></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); <span class="comment">// 2</span></span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同時進行-for-loop-dispatch-apply"><a href="#同時進行-for-loop-dispatch-apply" class="headerlink" title="同時進行 for loop  dispatch_apply"></a>同時進行 for loop  dispatch_apply</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line">    dispatch_apply(<span class="number">3</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^(size_t i) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup);</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但寫 app 時間有限，除非在非常大的 set 中，否則不要太 crazy。</p><h3 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h3><p>問題：太浪費 cpu</p><figure class="highlight objc"><figcaption><span>GooglyPuffTests.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    __block <span class="built_in">BOOL</span> isFinishedDownloading = <span class="literal">NO</span>;</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 isFinishedDownloading = <span class="literal">YES</span>;</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!isFinishedDownloading) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_semaphore_create 方式</p><figure class="highlight objc"><figcaption><span>GooglyPuffTests.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"> </span><br><span class="line">                                 <span class="comment">// 2</span></span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        <span class="built_in">XCTFail</span>(<span class="string">@"%@ timed out"</span>, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h3><p>蠻複雜的….</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="meta">#if DEBUG</span></span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">static</span> dispatch_source_t source = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      __<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          <span class="comment">// 6</span></span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, <span class="number">0</span>, queue);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 7</span></span><br><span class="line">          <span class="keyword">if</span> (source)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 8</span></span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  <span class="comment">// 9</span></span><br><span class="line">                  <span class="built_in">NSLog</span>(<span class="string">@"Hi, I am: %@"</span>, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); <span class="comment">// 10</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The other stuff</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;參考 &lt;a href=&quot;http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grand Central Dispatch In-Depth&lt;/a&gt; 的筆記。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Critical Section&lt;/li&gt;
&lt;li&gt;Race Condition&lt;/li&gt;
&lt;li&gt;Deadlock&lt;/li&gt;
&lt;li&gt;Context Switch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="GCD" scheme="http://chadchang.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Constants</title>
    <link href="http://chadchang.github.io/2014/03/30/constants/"/>
    <id>http://chadchang.github.io/2014/03/30/constants/</id>
    <published>2014-03-30T06:06:00.000Z</published>
    <updated>2016-11-18T14:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 的 constants 也是有學問的</p><p>常常是用 <code>#define myConstants var</code> 來處理一些變數，但更好的作法是用 const</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> MY_CONSTANT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants.m</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> MY_CONSTANT = <span class="string">@"my_constant"</span>;</span><br></pre></td></tr></table></figure><p>當希望此變數不為 global 時，則用 static</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants.m</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> CONSTANT = <span class="string">@"my_constant"</span>;</span><br></pre></td></tr></table></figure><p><code>#define</code> 在 code 中是用取代的方式，compiler也沒辦法做 type 檢查，<code>stringInstance == strConstant</code> 的方式也比 #define 中用<code>isEqualToString</code> 快</p><p>當要宣告 integer 時，apple 建議用<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> <span class="keyword">const</span> counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>但在loop中會有警告<code>Assignment of read-only variable ‘counter’</code>，需要用以下方式</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showTimer &#123;</span><br><span class="line">counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ref:<br><a href="http://webbuilders.wordpress.com/2011/03/02/constant-in-objective-c/" target="_blank" rel="noopener">Constant in Objective-C</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 的 constants 也是有學問的&lt;/p&gt;
&lt;p&gt;常常是用 &lt;code&gt;#define myConstants var&lt;/code&gt; 來處理一些變數，但更好的作法是用 const&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>import header時無法找到cocoapods 使用的framework header</title>
    <link href="http://chadchang.github.io/2013/10/25/import-headershi-wu-fa-zhao-dao-cocoapods-shi-yong-de-framework-header/"/>
    <id>http://chadchang.github.io/2013/10/25/import-headershi-wu-fa-zhao-dao-cocoapods-shi-yong-de-framework-header/</id>
    <published>2013-10-25T04:30:00.000Z</published>
    <updated>2016-11-18T14:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 .h file 中想要 import cocoapods 中的 lib 時，如果找不到，可以在 user header search path 中加上<code>&quot;${PODS_ROOT}/BuildHeaders&quot;</code>，並設為 recursive。</p><p>Reference: </p><p><a href="http://stackoverflow.com/questions/12002905/ios-build-fails-with-cocoapods-cannot-find-header-files" target="_blank" rel="noopener">http://stackoverflow.com/questions/12002905/ios-build-fails-with-cocoapods-cannot-find-header-files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 .h file 中想要 import cocoapods 中的 lib 時，如果找不到，可以在 user header search path 中加上&lt;code&gt;&amp;quot;${PODS_ROOT}/BuildHeaders&amp;quot;&lt;/code&gt;，並設為 recur
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://chadchang.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>Heroku : Sorry , I cannot find /</title>
    <link href="http://chadchang.github.io/2012/02/24/sorry/"/>
    <id>http://chadchang.github.io/2012/02/24/sorry/</id>
    <published>2012-02-24T09:12:00.000Z</published>
    <updated>2018-03-14T09:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<font color="red">Sorry, I cannot find /</font>  <p>因為一堆奇怪問題把 heroku 重裝之後，deploy 上去一直出現這問題，搞了半天才發現要把 .gitignore 的 <strong><strong>public</strong></strong> 移除，否則 heroku 沒辦法讀取到，一個下午又這樣沒了…QQ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;Sorry, I cannot find /&lt;/font&gt;  

&lt;p&gt;因為一堆奇怪問題把 heroku 重裝之後，deploy 上去一直出現這問題，搞了半天才發現要把 .gitignore 的 &lt;strong&gt;&lt;strong&gt;public&lt;/
      
    
    </summary>
    
    
      <category term="Heroku" scheme="http://chadchang.github.io/tags/Heroku/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 4.3 發佈</title>
    <link href="http://chadchang.github.io/2012/02/24/xcode-4-dot-3fa-bu/"/>
    <id>http://chadchang.github.io/2012/02/24/xcode-4-dot-3fa-bu/</id>
    <published>2012-02-24T03:52:00.000Z</published>
    <updated>2018-03-14T09:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>就算 Xcode 已經在 Mac Store 了，有新版的還是不會提示更新，用了最新 4.3 版發現一些不一樣：<br><a id="more"></a></p><ol><li>New file 出來的 template 又不同了，好像每次改版都不同…Orz</li><li>archive 後送審的 UI 調整</li><li>New file 時把 view 跟 controler 整合在一起，會自動把<em>ViewController</em>加到檔名之後，也可以直接輸入要繼承的 class，但有一點不方便的是如果不是繼承 UIViewController，就不能產生.xib…Orz</li></ol><p>目前發現的是這樣，<strong><strong><code>markdown 學習使用中</code></strong></strong>~</p><p><strong><em>2012.02.25 update</em></strong></p><ol><li>下方 console 的部份可以設定預設位置了，類似android可以手動發送想要設定的 GPS 給 device 功能  (終於…)</li><li>收到 Notification 時，裡面的 NSLog 在 console 印不出來，不過看 device 內的 console log 又有…</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就算 Xcode 已經在 Mac Store 了，有新版的還是不會提示更新，用了最新 4.3 版發現一些不一樣：&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://chadchang.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Review Clock v1.0 上架啦!!! (已下架)</title>
    <link href="http://chadchang.github.io/2011/12/18/review-clcok-v1-dot-0shang-jia-la/"/>
    <id>http://chadchang.github.io/2011/12/18/review-clcok-v1-dot-0shang-jia-la/</id>
    <published>2011-12-18T07:01:00.000Z</published>
    <updated>2016-11-18T14:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://itunes.apple.com/tw/app/review-clock/id488483008?mt=8" target="_blank" rel="noopener">下載網址</a></p><p>被兩送兩退後終於搞定了，希望這是真的對生活有幫助的實用app，<br>也希望大家喜歡，並努力改進當中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://itunes.apple.com/tw/app/review-clock/id488483008?mt=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下載網址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;被兩送兩退後終於搞定了，希望這是真的對
      
    
    </summary>
    
    
      <category term="Review Clock" scheme="http://chadchang.github.io/tags/Review-Clock/"/>
    
  </entry>
  
</feed>
