<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chad</title>
  
  <subtitle>一個對世界好奇的iOS Developer，時常玩玩 Android 小綠機器人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chadchang.github.io/"/>
  <updated>2021-02-19T12:38:04.532Z</updated>
  <id>http://chadchang.github.io/</id>
  
  <author>
    <name>Chad Chang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移除在 Cocoapods 上自己開發的 lib</title>
    <link href="http://chadchang.github.io/2021/02/19/deprecate-cocoapods-lib/"/>
    <id>http://chadchang.github.io/2021/02/19/deprecate-cocoapods-lib/</id>
    <published>2021-02-19T12:32:00.000Z</published>
    <updated>2021-02-19T12:38:04.532Z</updated>
    
    <content type="html"><![CDATA[<p>因為自己原本有放到 Cocoapods 的 library 想重寫一套而且是不同名稱，所以想要把原本的下架。</p><ol><li>先 <code>pod trunk register 當初申請的 email</code></li><li><code>pod trunk me</code> 可以看這帳號是哪些 library owner</li><li><code>pod trunk delete YOUR_LIB_NAME 1.1</code> 刪除 1.1 這版本 </li><li><code>pod trunk deprecate YOUR_LIB_NAME</code> 即可將這 library 標示為 deprecated</li></ol><p>似乎沒有完整刪除的辦法，看到大家也說不推薦這樣做</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因為自己原本有放到 Cocoapods 的 library 想重寫一套而且是不同名稱，所以想要把原本的下架。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先 &lt;code&gt;pod trunk register 當初申請的 email&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod trun
      
    
    </summary>
    
    
    
      <category term="cocoapods, iOS" scheme="http://chadchang.github.io/tags/cocoapods-iOS/"/>
    
  </entry>
  
  <entry>
    <title>在 Cocoapods Development Pod 中加入 Test</title>
    <link href="http://chadchang.github.io/2021/02/08/unit-test-in-cocoapods-development-pod/"/>
    <id>http://chadchang.github.io/2021/02/08/unit-test-in-cocoapods-development-pod/</id>
    <published>2021-02-08T11:05:08.000Z</published>
    <updated>2021-02-08T13:23:07.678Z</updated>
    
    <content type="html"><![CDATA[<p>當使用 Cocoapods 的 <code>pod lib create YourLib</code> 後，只會得到 Example Project 下的 Test 資料夾，這 Test 是包含 Host App 的，而在 Development Pod 中並不會包含 Test 資料夾。 這有點不方便也不直覺，不過經由設定即可得到以下比較好的檔案結構</p><a id="more"></a><p><img src="/images/test_in_developement_pods.png" alt="Development pods with Tests"></p><p>如要在 Development Pod 中加入 Test，則需要額外設定 (以CCRegionSelector為例)：</p><p>在 <code>CCRegionSelector.podspec</code> 中需要增加這段</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.test_spec <span class="string">'Tests'</span> <span class="keyword">do</span> <span class="params">|test_spec|</span></span><br><span class="line">  test_spec.source_files = <span class="string">'CCRegionSelector/Tests/*.swift'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 Example 中的 <code>Podfile</code> 中也需要增加 <code>:testspecs =&gt; [&#39;Tests&#39;]</code></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">'CCRegionSelector_Example'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'CCRegionSelector'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../'</span>, <span class="symbol">:testspecs</span> =&gt; [<span class="string">'Tests'</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊要注意的是必須先在 <code>Tests</code> 資料夾內先隨便新增一個檔案，不然會得到以下錯誤… 有點雷</p><blockquote><p>Unable to install the <code>CCRegionSelector</code> pod, because the <code>CCRegionSelector-Unit-Tests</code> target in Xcode would have no sources to compile.</p></blockquote><p>最後在 Example 資料夾內跑完 <code>pod install</code> 後如果沒看到新的 scheme，則在 Xcode 中 manage scheme 內將 <code>CCRegionSelector-Unit-Tests</code> show 打勾就完成了</p><p><img src="/images/add_unit_test_scheme.png" alt="add_unit_test_scheme"></p><blockquote><p>不過這樣即使還沒有 Host App，但跑測試還是會默默需要模擬器而無法更快測試，需要再看看有沒有解法可以加速</p></blockquote><p>在 CocoaPods 1.4 時支援設定是否需不需要 app host</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.test_spec <span class="string">'Tests'</span> <span class="keyword">do</span> <span class="params">|test_spec|</span></span><br><span class="line">  test_spec.requires_app_host = <span class="literal">true</span></span><br><span class="line">  test_spec.source_files = <span class="string">'Tests/*.&#123;h,m&#125;'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 CocoaPods 1.8 時支援 UITest bundle</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.test_spec <span class="string">'UITests'</span> <span class="keyword">do</span> <span class="params">|test_spec|</span></span><br><span class="line">  test_spec.requires_app_host = <span class="literal">true</span></span><br><span class="line">  test_spec.test_type = <span class="symbol">:ui</span></span><br><span class="line">  test_spec.source_files = <span class="string">'UITests/**/*.swift'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Ref:</p><ol><li><a href="https://guides.cocoapods.org/using/test-specs.html" target="_blank" rel="noopener">Testing with CocoaPods</a></li><li><a href="https://medium.com/mobile-app-development-publication/support-custom-configuration-in-local-pod-1298b86e2a12" target="_blank" rel="noopener">Support Custom Configuration in Local Pod</a></li><li><a href="https://blog.cocoapods.org/CocoaPods-1.8.0-beta/" target="_blank" rel="noopener">CocoaPods 1.8</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;當使用 Cocoapods 的 &lt;code&gt;pod lib create YourLib&lt;/code&gt; 後，只會得到 Example Project 下的 Test 資料夾，這 Test 是包含 Host App 的，而在 Development Pod 中並不會包含 Test 資料夾。 這有點不方便也不直覺，不過經由設定即可得到以下比較好的檔案結構&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小孩住院保險那些事</title>
    <link href="http://chadchang.github.io/2020/11/26/child-insurance/"/>
    <id>http://chadchang.github.io/2020/11/26/child-insurance/</id>
    <published>2020-11-26T13:42:06.000Z</published>
    <updated>2020-11-26T14:39:36.539Z</updated>
    
    <content type="html"><![CDATA[<p>第一次稍微研究保險是四年多前小孩出生後，不然也是父母在小時候幫我保的人情保單一直繳錢沒有再動過，<br>稍微了解後就也把我的跟太太的做了一些調整。繳了四年的保費直到最近小孩連續發燒四天後到大醫院住院，才又再把這些保單拿出來看，也因此有一些心得。身邊也越來越多朋友為人父母，因此在這分享出來。</p><h4 id="重點："><a href="#重點：" class="headerlink" title="重點："></a>重點：</h4><ol><li>如果學校有團保，看看有沒有住院醫療險，小孩的公幼就有提供。</li><li>公司如果有幫小孩保團保，也看看有沒有包含住院醫療險<br>(以上兩個通常都直覺只有意外險，沒想到皆有包含住院醫療險。)</li><li>到院當天沒有病房，所以在急診小兒區待了整整一天，這部份一般保險是不算住院的，也有少數保險有計算。</li><li>保險是用你的天數，而不是幾晚。不過病房費是用幾晚，這邊就會有多一點額度可以運用。</li><li>了解自己的保險額度到底是多少，這也是這篇想分享的重點。</li></ol><p>當沒病床要排隊時，院方問你要幾人房，因事前沒先準備，當下就只敢寫雙人跟三人健保房，因為再上去的單人房從一天 3000 ~ 12000 都有，如果清楚知道你的保險額是多少時就不用瞎猜了。</p><p><img src="/images/20201126-1.png" alt="保險額度"></p><p>(截自： <a href="https://finfo.tw/" target="_blank" rel="noopener">https://finfo.tw/</a>)</p><p>Finfo 這網站寫的蠻清楚的，輸入你買的單位後額度跟例子都寫給你看了。</p><p>這邊我們扣掉急診那晚總共在醫院四天三夜，這樣表示病房費有 2200 * 4 的額度，但我們雙人房一天 2000, 所以病房費只花了 6000。 另外這張還有住院補貼是60%，所以總額度就是6000x1.6 = 12800，而可申請最大值是 2200x4x 1.6 = 14080。 然後再加上右邊雜費手術費等。</p><p>另一種是如果上面算下來小於日額給付的話（這邊一天是2860），那可以改選日額給付，也不用附收據，尤其在多家保險都需要正本理賠時就要選擇哪一家用哪個方案比較好。</p><p>我們一輩子有極大機率會用到保險，能先了解這些在需要使用時能有一個底，或者可以享受更好住院醫療品質。</p><p>Note: 以上還沒實際申請理賠，不保證完全可以拿到我計算的，但有先跟保險業務員討論過了解大致是這樣計算的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次稍微研究保險是四年多前小孩出生後，不然也是父母在小時候幫我保的人情保單一直繳錢沒有再動過，&lt;br&gt;稍微了解後就也把我的跟太太的做了一些調整。繳了四年的保費直到最近小孩連續發燒四天後到大醫院住院，才又再把這些保單拿出來看，也因此有一些心得。身邊也越來越多朋友為人父母，因
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>genstrings script 同時支援 objc&amp;swift</title>
    <link href="http://chadchang.github.io/2018/06/26/genstring-for-objc-swift/"/>
    <id>http://chadchang.github.io/2018/06/26/genstring-for-objc-swift/</id>
    <published>2018-06-26T15:04:56.000Z</published>
    <updated>2018-06-27T16:31:49.690Z</updated>
    
    <content type="html"><![CDATA[<p>因 project 要開始慢慢導入 swift，不小心可能就沒注意到原本 genstrings script 不會處理 swift file,<br>而要改成能同時支援<code>.m</code>與<code>.swift</code>檔的 script</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find $&#123;SRCROOT&#125;&#x2F;MyApp&#x2F; \( -name &quot;*.swift&quot; -o -name &quot;*.m&quot; \) -print0 | xargs -0 genstrings -o $&#123;SRCROOT&#125;&#x2F;MyApp&#x2F;zh-Hant.lproj</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因 project 要開始慢慢導入 swift，不小心可能就沒注意到原本 genstrings script 不會處理 swift file,&lt;br&gt;而要改成能同時支援&lt;code&gt;.m&lt;/code&gt;與&lt;code&gt;.swift&lt;/code&gt;檔的 script&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chadchang.github.io/tags/Swift/"/>
    
      <category term="Objc" scheme="http://chadchang.github.io/tags/Objc/"/>
    
  </entry>
  
  <entry>
    <title>上了 Apple Store Today !!</title>
    <link href="http://chadchang.github.io/2018/05/25/apple-today/"/>
    <id>http://chadchang.github.io/2018/05/25/apple-today/</id>
    <published>2018-05-25T10:49:44.000Z</published>
    <updated>2018-05-31T01:12:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 P 社滿五年了，在 2016/11/04 的 “同一天 App Store、Google Play 雙 Feature” 之後，17 年又經過 apple pay 台灣首發的 app 跟官網 promote 的 app 後，18 年又達到在 App Store 首頁被選為 Today 的成就，值得再紀念一下。</p><p><img src="/images/today_1.PNG" alt="Today"> <img src="/images/today_2.PNG" alt="Today"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 P 社滿五年了，在 2016/11/04 的 “同一天 App Store、Google Play 雙 Feature” 之後，17 年又經過 apple pay 台灣首發的 app 跟官網 promote 的 app 後，18 年又達到在 App Store 首頁被選
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="App Store" scheme="http://chadchang.github.io/tags/App-Store/"/>
    
      <category term="Work" scheme="http://chadchang.github.io/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>用 Atom 寫 markdown</title>
    <link href="http://chadchang.github.io/2016/12/05/switch-to-atom/"/>
    <id>http://chadchang.github.io/2016/12/05/switch-to-atom/</id>
    <published>2016-12-05T10:42:47.000Z</published>
    <updated>2018-05-30T03:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Atom 剛發表時有安裝玩了一下，但當時不知道為什麼覺得不好用，直到又再翻到 <a href="http://www.slideshare.net/alemur1/atom-text-editor-resistance-is-futile" target="_blank" rel="noopener">Atom Text Editor: Resistance is Futile</a> 這份投影片，重新安裝 Atom 後光看畫面就很舒服，這篇也是在 Atom 底下寫出來的。建立好 markdown 的環境後，就可以與 sublime text 與 macdown 說再見了。</p><a id="more"></a><ol><li>環境修改： Settings -&gt; Core -&gt; Open Empty Editor on Start -&gt; 設定為關閉，否則每次開啟都會出現挺煩人的。</li><li>安裝 <code>markdown-writer</code> package<br>因此 package 將預設的 keymap 關閉，因此需在 Atom 上方的 File -&gt; Keymap 加上:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">".platform-darwin atom-text-editor[data-grammar~='gfm']"</span>:</span><br><span class="line">  <span class="string">"shift-cmd-K"</span>: <span class="string">"markdown-writer:insert-link"</span></span><br><span class="line">  <span class="string">"shift-cmd-I"</span>: <span class="string">"markdown-writer:insert-image"</span></span><br><span class="line">  <span class="string">"cmd-i"</span>:       <span class="string">"markdown-writer:toggle-italic-text"</span></span><br><span class="line">  <span class="string">"cmd-b"</span>:       <span class="string">"markdown-writer:toggle-bold-text"</span></span><br><span class="line">  <span class="string">"shift-cmd-'"</span>: <span class="string">"markdown-writer:toggle-code-text"</span></span><br><span class="line">  <span class="string">"cmd-k"</span>:       <span class="string">"markdown-writer:toggle-keystroke-text"</span></span><br><span class="line">  <span class="string">"cmd-h"</span>:       <span class="string">"markdown-writer:toggle-strikethrough-text"</span></span><br><span class="line">  <span class="string">"ctrl-alt-1"</span>:  <span class="string">"markdown-writer:toggle-h1"</span></span><br><span class="line">  <span class="string">"ctrl-alt-2"</span>:  <span class="string">"markdown-writer:toggle-h2"</span></span><br><span class="line">  <span class="string">"ctrl-alt-3"</span>:  <span class="string">"markdown-writer:toggle-h3"</span></span><br><span class="line">  <span class="string">"ctrl-alt-4"</span>:  <span class="string">"markdown-writer:toggle-h4"</span></span><br><span class="line">  <span class="string">"ctrl-alt-5"</span>:  <span class="string">"markdown-writer:toggle-h5"</span></span><br><span class="line">  <span class="string">"shift-cmd-O"</span>: <span class="string">"markdown-writer:toggle-ol"</span></span><br><span class="line">  <span class="string">"shift-cmd-U"</span>: <span class="string">"markdown-writer:toggle-ul"</span></span><br><span class="line">  <span class="string">"shift-cmd-&gt;"</span>: <span class="string">"markdown-writer:toggle-blockquote"</span></span><br><span class="line">  <span class="string">"cmd-'"</span>: <span class="string">"markdown-writer:toggle-codeblock-text"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-p"</span>: <span class="string">"markdown-writer:jump-to-previous-heading"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-n"</span>: <span class="string">"markdown-writer:jump-to-next-heading"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-d"</span>: <span class="string">"markdown-writer:jump-to-reference-definition"</span></span><br><span class="line">  <span class="string">"cmd-j cmd-t"</span>: <span class="string">"markdown-writer:jump-to-next-table-cell"</span></span><br></pre></td></tr></table></figure><p>注意： 這邊我將 code block 快捷鍵改為 <em>cmd-‘</em> 因為比 inline code 常用</p><ol start="3"><li>因較常使用 objc 的 code，將 code block 預設改為 “<code>objc</code>“ 樣式，設定檔修改請參考 <a href="https://github.com/zhuochun/md-writer/wiki/Settings" target="_blank" rel="noopener">Settings · zhuochun/md-writer Wiki</a> 與 <a href="https://github.com/zhuochun/md-writer/wiki/Settings-for-individual-projects" target="_blank" rel="noopener">Settings for Individual Projects · zhuochun/md-writer Wiki</a></li></ol><p>（以上兩點大大解決每次在 Mackdown 貼 code 的不便）</p><ol start="4"><li><p>因偶爾會使用 swift code，為了讓 Atom 認識 swift style，需安裝 <code>language-swift</code> package</p></li><li><p><code>ctrl - shift - m</code> 可以預覽。</p></li></ol><p>另外，用 <code>hexo</code> 的話，有 <code>Atom-Hexo</code> package 可以使用， markdown-writer 內也可以針對 site 詳細設定，但因為我都是用 terminal，所以這部份就忽略了，有興趣的話可以自己調整。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Atom 剛發表時有安裝玩了一下，但當時不知道為什麼覺得不好用，直到又再翻到 &lt;a href=&quot;http://www.slideshare.net/alemur1/atom-text-editor-resistance-is-futile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Atom Text Editor: Resistance is Futile&lt;/a&gt; 這份投影片，重新安裝 Atom 後光看畫面就很舒服，這篇也是在 Atom 底下寫出來的。建立好 markdown 的環境後，就可以與 sublime text 與 macdown 說再見了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Atom" scheme="http://chadchang.github.io/tags/Atom/"/>
    
      <category term="editor" scheme="http://chadchang.github.io/tags/editor/"/>
    
      <category term="markdown" scheme="http://chadchang.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Common Background Practice</title>
    <link href="http://chadchang.github.io/2016/11/21/background-practices/"/>
    <id>http://chadchang.github.io/2016/11/21/background-practices/</id>
    <published>2016-11-21T15:04:56.000Z</published>
    <updated>2016-11-21T15:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/issues/2-concurrency/common-background-practices/" target="_blank" rel="noopener">Common Background Practices - objc.io issue #2</a> 的整理筆記</p><a id="more"></a><h3 id="import-一大組資料-with-progress-bar"><a href="#import-一大組資料-with-progress-bar" class="headerlink" title="import 一大組資料 with progress bar"></a>import 一大組資料 with progress bar</h3><p>Start Import</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ImportOperation* operation = [[ImportOperation alloc] initWithStore:<span class="keyword">self</span>.store fileName:fileName];</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：更新 progress 必須在 main thread</span></span><br><span class="line">operation.progressCallback = ^(<span class="keyword">float</span> progress) &#123;</span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.progressIndicator.progress = progress;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br></pre></td></tr></table></figure><p>ImportOperation</p><figure class="highlight objc"><figcaption><span>ImportOperation.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithStore:(Store*)store fileName:(<span class="built_in">NSString</span>*)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.store = store;</span><br><span class="line">        <span class="keyword">self</span>.fileName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> can we use new in the name? I think it's bad style, any ideas for a better name?</span></span><br><span class="line">    <span class="keyword">self</span>.context = [<span class="keyword">self</span>.store newPrivateContext];</span><br><span class="line">    <span class="keyword">self</span>.context.undoManager = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.context performBlockAndWait:^</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> import];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)import</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* fileContents = [<span class="built_in">NSString</span> stringWithContentsOfFile:<span class="keyword">self</span>.fileName encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    <span class="built_in">NSArray</span>* lines = [fileContents componentsSeparatedByCharactersInSet:[<span class="built_in">NSCharacterSet</span> newlineCharacterSet]];</span><br><span class="line">    <span class="built_in">NSInteger</span> count = lines.count;</span><br><span class="line">    <span class="comment">// 每 100 行才更新一次 progress 避免阻塞</span></span><br><span class="line">    <span class="built_in">NSInteger</span> progressGranularity = count/<span class="number">100</span>;</span><br><span class="line">    __block <span class="built_in">NSInteger</span> idx = <span class="number">-1</span>;</span><br><span class="line">    [fileContents enumerateLinesUsingBlock:^(<span class="built_in">NSString</span>* line, <span class="built_in">BOOL</span>* shouldStop)</span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// header line</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 支持取消功能</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            *shouldStop = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSArray</span>* components = [line csvComponents];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (components.count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"couldn't parse: %@"</span>, components);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [Stop importCSVComponents:components intoContext:<span class="keyword">self</span>.context];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx % progressGranularity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.progressCallback(idx / (<span class="keyword">float</span>) count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx % ImportBatchSize == <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.context save:<span class="literal">NULL</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.progressCallback(<span class="number">1</span>);</span><br><span class="line">    [<span class="keyword">self</span>.context save:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Asynchronous-Networking"><a href="#Asynchronous-Networking" class="headerlink" title="Asynchronous Networking"></a>Asynchronous Networking</h3><p>不可以使用以下代碼，因為不可以取消，會阻塞 thread，在並行時也需要多一個 thread</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">   <span class="built_in">NSData</span>* contents = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]</span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="comment">// 處理 data</span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 <code>NSURLConnection</code> or <code>NSURLSessionConnection</code> 來解決</p><h3 id="File-I-O-in-the-Background"><a href="#File-I-O-in-the-Background" class="headerlink" title="File I/O in the Background"></a>File I/O in the Background</h3><p>當文件太大時，則需要一行一行的讀取而不是一次將整個文件讀入</p><figure class="highlight objc"><figcaption><span>Reader</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Reader</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block</span><br><span class="line">            completion:(<span class="keyword">void</span> (^)())completion;</span><br><span class="line">- (<span class="keyword">id</span>)initWithFileAtPath:(<span class="built_in">NSString</span>*)path;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implement</span></span><br><span class="line">- (<span class="keyword">void</span>)enumerateLines:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span>*))block</span><br><span class="line">            completion:(<span class="keyword">void</span> (^)())completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.queue == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.callback = block;</span><br><span class="line">    <span class="keyword">self</span>.completion = completion;</span><br><span class="line">    <span class="keyword">self</span>.inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.fileURL];</span><br><span class="line">    <span class="keyword">self</span>.inputStream.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop]</span><br><span class="line">                                forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inputStream 的 delegate</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stream:(<span class="built_in">NSStream</span>*)stream handleEvent:(<span class="built_in">NSStreamEvent</span>)eventCode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventCode) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSStreamEventHasBytesAvailable</span>: &#123;</span><br><span class="line">            <span class="built_in">NSMutableData</span> *buffer = [<span class="built_in">NSMutableData</span> dataWithLength:<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">NSUInteger</span> length = [<span class="keyword">self</span>.inputStream read:[buffer mutableBytes]</span><br><span class="line">                                             maxLength:[buffer length]];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; length) &#123;</span><br><span class="line">                [buffer setLength:length];</span><br><span class="line">                __<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">                [<span class="keyword">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class="line">                    [weakSelf processDataChunk:buffer];</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processDataChunk:(<span class="built_in">NSMutableData</span> *)buffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.remainder != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.remainder appendData:buffer];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.remainder = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.remainder obj_enumerateComponentsSeparatedBy:<span class="keyword">self</span>.delimiter</span><br><span class="line">                                            usingBlock:^(<span class="built_in">NSData</span>* component, <span class="built_in">BOOL</span> last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!last) &#123;</span><br><span class="line">            [<span class="keyword">self</span> emitLineWithData:component];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; [component length]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = [component mutableCopy];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.remainder = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/issues/2-concurrency/common-background-practices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Common Background Practices - objc.io issue #2&lt;/a&gt; 的整理筆記&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="objc.io" scheme="http://chadchang.github.io/tags/objc-io/"/>
    
  </entry>
  
  <entry>
    <title>Concurrent Programming 的 API</title>
    <link href="http://chadchang.github.io/2016/11/19/objcio-2-api/"/>
    <id>http://chadchang.github.io/2016/11/19/objcio-2-api/</id>
    <published>2016-11-19T15:43:36.000Z</published>
    <updated>2016-11-20T17:32:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">Concurrent Programming: APIs and Challenges - objc.io issue #2</a> 的整理筆記</p><a id="more"></a><p>難 -&gt; 易 : pthread、NSThread、GCD、NSOperationQueue</p><h3 id="使用-GCD"><a href="#使用-GCD" class="headerlink" title="使用 GCD"></a>使用 GCD</h3><p>預設有五個 queue</p><ol><li>main queue</li><li>3 個不同 priority queue</li><li>I/O queue</li></ol><p>大多數情況使用 default 的 priority queue 就好，避免 <code>priority inversion</code></p><h3 id="使用-Operation-Queues"><a href="#使用-Operation-Queues" class="headerlink" title="使用 Operation Queues"></a>使用 Operation Queues</h3><p>可透過 override main or start 定義自己的 operations。</p><p>重寫 main 的方式當 return 時，這 operation 就結束了</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">    - (<span class="keyword">void</span>)main</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 進行處理 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>更多處理或者要可以 async，這情況下需要手動管理狀態，使用預設的 setter 才會發送 KVO，否則需要自己發送。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YourOperation</span></span></span><br><span class="line">    - (<span class="keyword">void</span>)start</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.isExecuting = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 開始處理，在結束時應該調用 finished ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    - (<span class="keyword">void</span>)finished</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.isExecuting = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.isFinished = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>為了使用 cancel，需一直檢查 isCancelled 屬性。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (notDone &amp;&amp; !<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="comment">// 進行處理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>將 operation 放到 queue 中</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">YourOperation *operation = [[YourOperation alloc] init];</span><br><span class="line">[queue  addOperation:operation];</span><br></pre></td></tr></table></figure><p>也可以直接將 block 放到 queue 中，但定義自己的 NSOperation 會比較好 debug。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 代碼...</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>NSOperation 還可以透過 <code>maxConcurrentOperationCount</code> 控制同時執行的數量，還有根據 queue 中的 operation 的 priority 排序，還可以在 operation 之間設 dependency。</p><p>而性能雖然比 GCD 要低一點，但大多數可以忽略不計。</p><h3 id="使用-NSThread"><a href="#使用-NSThread" class="headerlink" title="使用 NSThread"></a>使用 NSThread</h3><p>使用這的問題是在我們的 code 中也做了建立 thread 的事情，可能導致 threads 爆炸。</p><figure class="highlight objc"><figcaption><span>FindMinMaxThread.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FindMinMaxThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> min;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> max;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FindMinMaxThread.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FindMinMaxThread</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _numbers = numbers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> min;</span><br><span class="line">    <span class="built_in">NSUInteger</span> max;</span><br><span class="line">    <span class="comment">// 進行相關數據的處理</span></span><br><span class="line">    <span class="keyword">self</span>.min = min;</span><br><span class="line">    <span class="keyword">self</span>.max = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>呼叫的方式</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableSet</span> *threads = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line"><span class="built_in">NSUInteger</span> numberCount = <span class="keyword">self</span>.numbers.count;</span><br><span class="line"><span class="built_in">NSUInteger</span> threadCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> offset = (count / threadCount) * i;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(offset, count);</span><br><span class="line">    <span class="built_in">NSArray</span> *subset = [<span class="keyword">self</span>.numbers subarrayWithRange:range];</span><br><span class="line">    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class="line">    [threads addObject:thread];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-pthread"><a href="#使用-pthread" class="headerlink" title="使用 pthread"></a>使用 pthread</h3><p>複雜不易使用</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> threadInfo &#123;</span><br><span class="line">    uint32_t * inputValues;</span><br><span class="line">    size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> threadResult &#123;</span><br><span class="line">    uint32_t min;</span><br><span class="line">    uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * findMinAndMax(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> threadInfo <span class="keyword">const</span> * <span class="keyword">const</span> info = (<span class="keyword">struct</span> threadInfo *) arg;</span><br><span class="line">    uint32_t min = <span class="built_in">UINT32_MAX</span>;</span><br><span class="line">    uint32_t max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; info-&gt;count; ++i) &#123;</span><br><span class="line">        uint32_t v = info-&gt;inputValues[i];</span><br><span class="line">        min = MIN(min, v);</span><br><span class="line">        max = MAX(max, v);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arg);</span><br><span class="line">    <span class="keyword">struct</span> threadResult * <span class="keyword">const</span> result = (<span class="keyword">struct</span> threadResult *) malloc(<span class="keyword">sizeof</span>(*result));</span><br><span class="line">    result-&gt;min = min;</span><br><span class="line">    result-&gt;max = max;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    size_t <span class="keyword">const</span> count = <span class="number">1000000</span>;</span><br><span class="line">    uint32_t inputValues[count];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用隨機數字填充 inputValues</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        inputValues[i] = arc4random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 開始4個尋找最小值和最大值的線程</span></span><br><span class="line">    size_t <span class="keyword">const</span> threadCount = <span class="number">4</span>;</span><br><span class="line">    pthread_t tid[threadCount];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> threadInfo * <span class="keyword">const</span> info = (<span class="keyword">struct</span> threadInfo *) malloc(<span class="keyword">sizeof</span>(*info));</span><br><span class="line">        size_t offset = (count / threadCount) * i;</span><br><span class="line">        info-&gt;inputValues = inputValues + offset;</span><br><span class="line">        info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(tid + i, <span class="literal">NULL</span>, &amp;findMinAndMax, info);</span><br><span class="line">        <span class="built_in">NSCAssert</span>(err == <span class="number">0</span>, <span class="string">@"pthread_create() failed: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待線程退出</span></span><br><span class="line">    <span class="keyword">struct</span> threadResult * results[threadCount];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> err = pthread_join(tid[i], (<span class="keyword">void</span> **) &amp;(results[i]));</span><br><span class="line">        <span class="built_in">NSCAssert</span>(err == <span class="number">0</span>, <span class="string">@"pthread_join() failed: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尋找 min 和 max</span></span><br><span class="line">    uint32_t min = <span class="built_in">UINT32_MAX</span>;</span><br><span class="line">    uint32_t max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        min = MIN(min, results[i]-&gt;min);</span><br><span class="line">        max = MAX(max, results[i]-&gt;max);</span><br><span class="line">        free(results[i]);</span><br><span class="line">        results[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"min = %u"</span>, min);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"max = %u"</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Concurrent Programming: APIs and Challenges - objc.io issue #2&lt;/a&gt; 的整理筆記&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="objc.io" scheme="http://chadchang.github.io/tags/objc-io/"/>
    
  </entry>
  
  <entry>
    <title>做一個 Side Project</title>
    <link href="http://chadchang.github.io/2016/11/08/side-project/"/>
    <id>http://chadchang.github.io/2016/11/08/side-project/</id>
    <published>2016-11-08T13:24:39.000Z</published>
    <updated>2018-06-01T06:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 App 寫了 六七年後，反而想再回去寫一點 Web 等不同於 App 的東西，畢竟過了這麼多年，現在整個 Web 世界又大大不同了。看到灣區日報的作者一直在持續推進他的東西，也學寫了 App 而且更新頻繁，一直在想自己有沒有可以效法他好好做一個自己用會感到興奮的東西。在思考之餘，剛好又在灣區日報看到了這篇 <a href="https://ponyfoo.com/articles/making-time-for-side-projects" target="_blank" rel="noopener">Making Time for Side Projects: A Daily Habit</a>，更確定是該來做些什麼了 :smile:</p><ol><li>It’s easier to get started</li><li>The pressure is off</li><li>You stop relying on motivation &amp; inspiration</li></ol><p>灣區日報作者的經驗我覺得很值得可以參考:</p><blockquote><p>我的經驗是，做 side project 的話，家裡的電腦永遠不關機，永遠開著 IDE、開發用的虛擬機、瀏覽器的 DevTools、iTerm2 等，每天有時間就做個 1、2 小時，沒時間弄個 10 分鐘、15 分鐘改個字體大小、顏色啥的也行，保持開發環境不變，第二天一有空閒就能接下去寫、很快進入狀態。</p></blockquote><p>每天都投入一點，即便只是五分鐘十分鐘，都是讓 side project 更前進。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 App 寫了 六七年後，反而想再回去寫一點 Web 等不同於 App 的東西，畢竟過了這麼多年，現在整個 Web 世界又大大不同了。看到灣區日報的作者一直在持續推進他的東西，也學寫了 App 而且更新頻繁，一直在想自己有沒有可以效法他好好做一個自己用會感到興奮的東西。在
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>同一天 App Store、Google Play 雙 Feature</title>
    <link href="http://chadchang.github.io/2016/10/21/feature/"/>
    <id>http://chadchang.github.io/2016/10/21/feature/</id>
    <published>2016-10-20T16:49:44.000Z</published>
    <updated>2016-11-03T17:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>App 從無到有的開發三年多，每天與同事們灌溉著 iOS/Android 這兩版本的 App，雖然已經上榜很多次，但這次是比較重大的，且兩版本同一天被 Feature 對我而言也是挺難得的。發文紀念一下。也謝謝強大的同事們的力量讓這 App 可以飛上天空。</p><p><img src="/images/app_store_feature.jpg" alt="App Store Feature"> <img src="/images/google_play_feature.png" alt="Google Play Feature"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;App 從無到有的開發三年多，每天與同事們灌溉著 iOS/Android 這兩版本的 App，雖然已經上榜很多次，但這次是比較重大的，且兩版本同一天被 Feature 對我而言也是挺難得的。發文紀念一下。也謝謝強大的同事們的力量讓這 App 可以飛上天空。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="App Store" scheme="http://chadchang.github.io/tags/App-Store/"/>
    
      <category term="Android" scheme="http://chadchang.github.io/tags/Android/"/>
    
      <category term="Google Play" scheme="http://chadchang.github.io/tags/Google-Play/"/>
    
      <category term="Work" scheme="http://chadchang.github.io/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>GCD 筆記</title>
    <link href="http://chadchang.github.io/2014/05/10/gcd/"/>
    <id>http://chadchang.github.io/2014/05/10/gcd/</id>
    <published>2014-05-10T04:08:00.000Z</published>
    <updated>2016-11-19T01:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>參考 <a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="noopener">Grand Central Dispatch In-Depth</a> 的筆記。</p><ul><li>Critical Section</li><li>Race Condition</li><li>Deadlock</li><li>Context Switch</li></ul><a id="more"></a><h3 id="背景讀取-dispatch-async"><a href="#背景讀取-dispatch-async" class="headerlink" title="背景讀取 dispatch_async"></a>背景讀取 dispatch_async</h3><figure class="highlight objc"><figcaption><span>PhotoDetailViewController.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;   </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSAssert</span>(_image, <span class="string">@"Image not set; required to use view controller"</span>);</span><br><span class="line">    <span class="keyword">self</span>.photoImageView.image = _image;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Resize if neccessary to ensure it's not pixelated</span></span><br><span class="line">    <span class="keyword">if</span> (_image.size.height &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.height &amp;&amp;</span><br><span class="line">        _image.size.width &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.width) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.photoImageView setContentMode:<span class="built_in">UIViewContentModeCenter</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">UIImage</span> *overlayImage = [<span class="keyword">self</span> faceOverlayImageFromImage:_image];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 2</span></span><br><span class="line">            [<span class="keyword">self</span> fadeInNewImage:overlayImage]; <span class="comment">// 3</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="幾秒後提示-dispatch-after"><a href="#幾秒後提示-dispatch-after" class="headerlink" title="幾秒後提示 dispatch_after"></a>幾秒後提示 dispatch_after</h3><p><img src="/images/gcdpromotes.png" alt="GCD promote"></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showOrHideNavPrompt PhotoCollectionViewController.m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [[PhotoManager sharedManager] photos].count;</span><br><span class="line">    <span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>)); <span class="comment">// 1 </span></span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123; <span class="comment">// 2 </span></span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="string">@"Add photos with faces to Googlyify them!"</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_after 最好使用在 main queue</strong></p><ul><li>Custom Serial Queue: Use caution when using dispatch_after on a custom serial queue. You’re better off sticking to the main queue.</li><li>Main Queue (Serial): This is a good choice for dispatch_after; Xcode has a nice autocomplete template for this.</li><li>Concurrent Queue: Use caution when using dispatch_after on custom concurrent queues; it’s rare that you’ll do this. Stick to the main queue for these operations.</li></ul><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init];</span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讀寫問題-dispatch-barrier"><a href="#讀寫問題-dispatch-barrier" class="headerlink" title="讀寫問題 dispatch_barrier"></a>讀寫問題 dispatch_barrier</h3><p>問題</p><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (photo) &#123;</span><br><span class="line">        [_photosArray addObject:photo];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> postContentAddedNotification];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)photos</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:_photosArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_barrier 最好使用在 Custom Concurrent Queue</strong></p><ul><li>Custom Serial Queue: A bad choice here; barriers won’t do anything helpful since a serial queue executes one operation at a time anyway.</li><li>Global Concurrent Queue: Use caution here; this probably isn’t the best idea since other systems might be using the queues and you don’t want to monopolize them for your own purposes.</li><li>Custom Concurrent Queue: This is a great choice for atomic or critical areas of code. Anything you’re setting or instantiating that needs to be thread safe is a great candidate for a barrier.</li></ul><p>修正</p><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PhotoManager</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *photosArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentPhotoQueue; <span class="comment">///&lt; Add this</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ADD THIS:</span></span><br><span class="line">sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(<span class="string">"com.selander.GooglyPuff.photoQueue"</span>,DISPATCH_QUEUE_CONCURRENT); </span><br><span class="line">                                                    </span><br><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (photo) &#123; <span class="comment">// 1</span></span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2 </span></span><br><span class="line">            [_photosArray addObject:photo]; <span class="comment">// 3</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 4</span></span><br><span class="line">                [<span class="keyword">self</span> postContentAddedNotification]; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)photos</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *array; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2</span></span><br><span class="line">        array = [<span class="built_in">NSArray</span> arrayWithArray:_photosArray]; <span class="comment">// 3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h3><p>在讀取時，reader function 沒return時是無效的，所以採用<code>dispatch_sync</code></p><p>讓 read 使用 sync 且與 write 在同一個 concurrent queeue 是確保 read ＆ wirte 有順序，且避免多 thread 讀寫。</p><p><strong>dispatch_sync 最好使用在 Custom Concurrent Queue</strong></p><ul><li>Custom Serial Queue: Be VERY careful in this situation; if you’re running in a queue and call dispatch_sync targeting the same queue, you will definitely create a deadlock.</li><li>Main Queue (Serial): Be VERY careful for the same reasons as above; this situation also has potential for a deadlock condition.</li><li>Concurrent Queue: This is a good candidate to sync work through dispatch barriers or when waiting for a task to complete so you can perform further processing.</li></ul><h3 id="全部圖片下載完後提示-dispatch-group"><a href="#全部圖片下載完後提示-dispatch-group" class="headerlink" title="全部圖片下載完後提示 dispatch_group"></a>全部圖片下載完後提示 dispatch_group</h3><figure class="highlight objc"><figcaption><span>PhotoManager.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">        __block <span class="built_in">NSError</span> *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *url;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            dispatch_group_enter(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                      <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); <span class="comment">// 4</span></span><br><span class="line">                                  &#125;];</span><br><span class="line"> </span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123; <span class="comment">// 7</span></span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_group 皆可使用在各種 Queue</strong></p><ul><li>Custom Serial Queue: This is a good candidate for notifications when a group of tasks completes.</li><li>Main Queue (Serial): This is a good candidate as well in this scenario. You should be wary of using this on the main queue if you are waiting synchronously for the completion of all work since you don’t want to hold up the main thread. However, the asynchronous model is an attractive way to update the UI once several long-running tasks finish such as network calls.</li><li>Concurrent Queue: This as well is a good candidate for dispatch groups and completion notifications.</li></ul><p><strong>比較簡潔方式</strong></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); <span class="comment">// 2</span></span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同時進行-for-loop-dispatch-apply"><a href="#同時進行-for-loop-dispatch-apply" class="headerlink" title="同時進行 for loop  dispatch_apply"></a>同時進行 for loop  dispatch_apply</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line">    dispatch_apply(<span class="number">3</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^(size_t i) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup);</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但寫 app 時間有限，除非在非常大的 set 中，否則不要太 crazy。</p><h3 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h3><p>問題：太浪費 cpu</p><figure class="highlight objc"><figcaption><span>GooglyPuffTests.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    __block <span class="built_in">BOOL</span> isFinishedDownloading = <span class="literal">NO</span>;</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 isFinishedDownloading = <span class="literal">YES</span>;</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!isFinishedDownloading) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_semaphore_create 方式</p><figure class="highlight objc"><figcaption><span>GooglyPuffTests.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"> </span><br><span class="line">                                 <span class="comment">// 2</span></span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        <span class="built_in">XCTFail</span>(<span class="string">@"%@ timed out"</span>, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h3><p>蠻複雜的….</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">static</span> dispatch_source_t source = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      __<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          <span class="comment">// 6</span></span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, <span class="number">0</span>, queue);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 7</span></span><br><span class="line">          <span class="keyword">if</span> (source)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 8</span></span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  <span class="comment">// 9</span></span><br><span class="line">                  <span class="built_in">NSLog</span>(<span class="string">@"Hi, I am: %@"</span>, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); <span class="comment">// 10</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The other stuff</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;參考 &lt;a href=&quot;http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grand Central Dispatch In-Depth&lt;/a&gt; 的筆記。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Critical Section&lt;/li&gt;
&lt;li&gt;Race Condition&lt;/li&gt;
&lt;li&gt;Deadlock&lt;/li&gt;
&lt;li&gt;Context Switch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="GCD" scheme="http://chadchang.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Constants</title>
    <link href="http://chadchang.github.io/2014/03/30/constants/"/>
    <id>http://chadchang.github.io/2014/03/30/constants/</id>
    <published>2014-03-30T06:06:00.000Z</published>
    <updated>2016-11-18T14:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 的 constants 也是有學問的</p><p>常常是用 <code>#define myConstants var</code> 來處理一些變數，但更好的作法是用 const</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> MY_CONSTANT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants.m</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> MY_CONSTANT = <span class="string">@"my_constant"</span>;</span><br></pre></td></tr></table></figure><p>當希望此變數不為 global 時，則用 static</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants.m</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> CONSTANT = <span class="string">@"my_constant"</span>;</span><br></pre></td></tr></table></figure><p><code>#define</code> 在 code 中是用取代的方式，compiler也沒辦法做 type 檢查，<code>stringInstance == strConstant</code> 的方式也比 #define 中用<code>isEqualToString</code> 快</p><p>當要宣告 integer 時，apple 建議用</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> <span class="keyword">const</span> counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>但在loop中會有警告<code>Assignment of read-only variable ‘counter’</code>，需要用以下方式</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showTimer &#123;</span><br><span class="line">counter += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ref:<br><a href="http://webbuilders.wordpress.com/2011/03/02/constant-in-objective-c/" target="_blank" rel="noopener">Constant in Objective-C</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 的 constants 也是有學問的&lt;/p&gt;
&lt;p&gt;常常是用 &lt;code&gt;#define myConstants var&lt;/code&gt; 來處理一些變數，但更好的作法是用 const&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>import header時無法找到cocoapods 使用的framework header</title>
    <link href="http://chadchang.github.io/2013/10/25/import-headershi-wu-fa-zhao-dao-cocoapods-shi-yong-de-framework-header/"/>
    <id>http://chadchang.github.io/2013/10/25/import-headershi-wu-fa-zhao-dao-cocoapods-shi-yong-de-framework-header/</id>
    <published>2013-10-25T04:30:00.000Z</published>
    <updated>2016-11-18T14:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 .h file 中想要 import cocoapods 中的 lib 時，如果找不到，可以在 user header search path 中加上<code>&quot;${PODS_ROOT}/BuildHeaders&quot;</code>，並設為 recursive。</p><p>Reference: </p><p><a href="http://stackoverflow.com/questions/12002905/ios-build-fails-with-cocoapods-cannot-find-header-files" target="_blank" rel="noopener">http://stackoverflow.com/questions/12002905/ios-build-fails-with-cocoapods-cannot-find-header-files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 .h file 中想要 import cocoapods 中的 lib 時，如果找不到，可以在 user header search path 中加上&lt;code&gt;&amp;quot;${PODS_ROOT}/BuildHeaders&amp;quot;&lt;/code&gt;，並設為 recur
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://chadchang.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>Heroku : Sorry , I cannot find /</title>
    <link href="http://chadchang.github.io/2012/02/24/sorry/"/>
    <id>http://chadchang.github.io/2012/02/24/sorry/</id>
    <published>2012-02-24T09:12:00.000Z</published>
    <updated>2018-03-14T09:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color='red'>Sorry, I cannot find /</font>  </p><p>因為一堆奇怪問題把 heroku 重裝之後，deploy 上去一直出現這問題，搞了半天才發現要把 .gitignore 的 <strong><strong>public</strong></strong> 移除，否則 heroku 沒辦法讀取到，一個下午又這樣沒了…QQ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&#39;red&#39;&gt;Sorry, I cannot find /&lt;/font&gt;  &lt;/p&gt;
&lt;p&gt;因為一堆奇怪問題把 heroku 重裝之後，deploy 上去一直出現這問題，搞了半天才發現要把 .gitignore 的 &lt;strong&gt;&lt;strong&gt;pu
      
    
    </summary>
    
    
    
      <category term="Heroku" scheme="http://chadchang.github.io/tags/Heroku/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 4.3 發佈</title>
    <link href="http://chadchang.github.io/2012/02/24/xcode-4-dot-3fa-bu/"/>
    <id>http://chadchang.github.io/2012/02/24/xcode-4-dot-3fa-bu/</id>
    <published>2012-02-24T03:52:00.000Z</published>
    <updated>2018-03-14T09:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>就算 Xcode 已經在 Mac Store 了，有新版的還是不會提示更新，用了最新 4.3 版發現一些不一樣：</p><a id="more"></a><ol><li>New file 出來的 template 又不同了，好像每次改版都不同…Orz</li><li>archive 後送審的 UI 調整</li><li>New file 時把 view 跟 controler 整合在一起，會自動把_ViewController_加到檔名之後，也可以直接輸入要繼承的 class，但有一點不方便的是如果不是繼承 UIViewController，就不能產生.xib…Orz</li></ol><p>目前發現的是這樣，<strong><strong><code>markdown 學習使用中</code></strong></strong>~</p><p><strong><em>2012.02.25 update</em></strong></p><ol><li>下方 console 的部份可以設定預設位置了，類似android可以手動發送想要設定的 GPS 給 device 功能  (終於…)</li><li>收到 Notification 時，裡面的 NSLog 在 console 印不出來，不過看 device 內的 console log 又有…</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就算 Xcode 已經在 Mac Store 了，有新版的還是不會提示更新，用了最新 4.3 版發現一些不一樣：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="iOS" scheme="http://chadchang.github.io/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://chadchang.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Review Clock v1.0 上架啦!!! (已下架)</title>
    <link href="http://chadchang.github.io/2011/12/18/review-clcok-v1-dot-0shang-jia-la/"/>
    <id>http://chadchang.github.io/2011/12/18/review-clcok-v1-dot-0shang-jia-la/</id>
    <published>2011-12-18T07:01:00.000Z</published>
    <updated>2016-11-18T14:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://itunes.apple.com/tw/app/review-clock/id488483008?mt=8" target="_blank" rel="noopener">下載網址</a></p><p>被兩送兩退後終於搞定了，希望這是真的對生活有幫助的實用app，<br>也希望大家喜歡，並努力改進當中。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://itunes.apple.com/tw/app/review-clock/id488483008?mt=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下載網址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;被兩送兩退後終於搞定了，希望這是真的對
      
    
    </summary>
    
    
    
      <category term="Review Clock" scheme="http://chadchang.github.io/tags/Review-Clock/"/>
    
  </entry>
  
</feed>
